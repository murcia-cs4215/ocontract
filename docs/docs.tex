\documentclass[a4paper]{article}

\usepackage[utf8]{inputenc}
\usepackage{amstext}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{color,soul}
\usepackage{tikz}
\usepackage{listings, lstautogobble}
\usepackage{xcolor}
\usepackage{url}
\usepackage{hyperref}
\usepackage{multirow}

% For code listing %
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

% Rule Commands
\newcommand{\Rule}[2]{\genfrac{}{}{0.7pt}{}{{\setlength{\fboxrule}{0pt}\setlength{\fboxsep}{3mm}\fbox{$#1$}}}{{\setlength{\fboxrule}{0pt}\setlength{\fboxsep}{3mm}\fbox{$#2$}}}}
\newcommand{\Rulee}[3]{\genfrac{}{}{0.7pt}{}{{\setlength{\fboxrule}{0pt}\setlength{\fboxsep}{3mm}\fbox{$#1$}}}{{\setlength{\fboxrule}{0pt}\setlength{\fboxsep}{3mm}\fbox{$#2$}}}[#3]}
\newcommand{\RuleWithName}[3]{\genfrac{}{}{0.7pt}{}{{\setlength{\fboxrule}{0pt}\setlength{\fboxsep}{3mm}\fbox{$#1$}}}{{\setlength{\fboxrule}{0pt}\setlength{\fboxsep}{3mm}\fbox{$#2$}}}[\text{#3}]}
\newcommand{\transition}{\rightrightarrows_s}
\newcommand{\translate}{\twoheadrightarrow}
\newcommand{\translateaux}{\hookrightarrow}
\newcommand{\Return}{\texttt{return}}
\newcommand{\Recfun}{\texttt{recfun}}
\newcommand{\If}{\texttt{if}}
\newcommand{\Then}{\texttt{then}}
\newcommand{\Else}{\texttt{else}}
\newcommand{\End}{\texttt{end}}
\newcommand{\Let}{\texttt{const}}
\newcommand{\In}{\texttt{in}}
\newcommand{\Rc}{\texttt{\}}}
\newcommand{\Lc}{\texttt{\{}}
\newcommand{\Times}{\texttt{*}}
\newcommand{\Plus}{\texttt{+}}
\newcommand{\TruE}{\texttt{true}}
\newcommand{\FalsE}{\texttt{false}}
\newcommand{\Int}{\texttt{int}}
\newcommand{\Float}{\texttt{float}}
\newcommand{\String}{\texttt{string}}
\newcommand{\Char}{\texttt{char}}
\newcommand{\Num}{\texttt{numeric}}
\newcommand{\Contract}{\texttt{contract}}
\newcommand{\Bool}{\texttt{bool}}
\newcommand{\Undefined}{\texttt{undefined}}
\newcommand{\X}{\texttt{x}}
\newcommand{\F}{\texttt{f}}
\newcommand{\LET}{\texttt{LET}}
\newcommand{\END}{\texttt{END}}
\newcommand{\IN}{\texttt{IN}}
\newcommand{\eval}{\rightarrowtail}
\newcommand{\evaL}{\rightarrowtail}
\newcommand{\partfun}{\rightsquigarrow}
\newcommand{\under}{\Vdash}
\newcommand{\ErroR}{\bot}
\newcommand{\Rp}{\texttt{)}}
\newcommand{\Lp}{\texttt{(}}
\newcommand{\Rb}{\texttt{\}}}
\newcommand{\Lb}{\texttt{\{}}
\newcommand{\blame}{\texttt{blame }}
\newcommand{\flatCon}{\texttt{con}}
\newcommand{\funCon}{\texttt{con1} \rightarrow \texttt{con2}}
\newcommand{\isFlat}{\texttt{flat}}
\newcommand{\conA}{\texttt{con1}}
\newcommand{\conB}{\texttt{con2}}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,
    breaklines=false,
    captionpos=b,
    keepspaces=false,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2,
    autogobble=true
}

\lstset{style=mystyle}

\evensidemargin 35pt % Align even and odd numbered pages
\setlength{\parindent}{0in} % Paragraph Indentation
\setlength{\parskip}{\medskipamount} % Spaces between paragraphs

% Horizontal Margins
\setlength{\oddsidemargin}{-0.25in} % Left margin 1 inch (0 + 1)
\setlength{\textwidth}{6.75in} % Text width 6.5 inch (so right margin 1 inch).

% Vertical Margins
\setlength{\topmargin}{-0.75in} % Top margin 0.5 inch (-0.5 + 1)
\setlength{\headheight}{0.25in} % Head height 0.25 inch (where page headers go)
\setlength{\headsep}{0.25in} % Head separation 0.25 inch (between header and top line of text)
\setlength{\textheight}{10.25in} % Text height 8.5 inch (so bottom margin 1.5 in)

\title{OContract}
\author{Rayson Koh (A0149884J), Zhu Hanming (A0196737L)}
\date{March 2022}

% Generate diagram using https://www.mathcha.io/editor %

\begin{document}
\pagenumbering{gobble}% Remove page numbers (and reset to 1)

% Cover Page %
\begin{titlepage}
    \begin{center}
        \vspace*{1cm}

        \Huge
        \textbf{OContract}

        \vspace{0.5cm}
        \LARGE
        Assertion-Based Contracts and Blame Passing for OCaml

        \vspace{1.5cm}


        \vfill

        A paper presented for \textbf{CS4215}

        \vspace{0.8cm}

        \includegraphics[width=0.4\textwidth]{nus-logo.jpg}

        \Large
        \textbf{Rayson Koh (A0149884J),\\Zhu Hanming (A0196737L)}\\
        School of Computing\\
        National University of Singapore\\
        March 2022

    \end{center}
\end{titlepage}

\tableofcontents
\newpage

\pagenumbering{arabic}
\section{Introduction}

Assertions as a programming language construct have great practical significance as it has been shown to be very useful in making robust software systems \cite{rosen}.
Also, as functional programming languages becomes increasingly more popular, there is a greater need for such languages to support assertion-based contracts in a higher-order world.

As such, we will be discussing about the design and implementation of OContract, a spin-off of OCaml that supports higher-order contract-based assertions.
We hope that OContract would serve as a proof-of-concept of the ideas as described in the landmark paper \emph{Contracts for Higher-Order Functions} \cite{contracts}.

The first main section, Section \ref{user}, will largely be on user-level documentation. This would include high-level descriptions of OContract's features as well as some example programs.
The second main section, Section \ref{developer}, will be on developer documentation which would include detailed technical specifications and implementation details of OContract.

\section{OContract Features}
\label{user}

This section lists the various features that OContract offers.
For a complete technical specification of OContract, please refer to the developer documentation in Section \ref{developer}.

It is recommended that users run OContract programs on the dedicated online code editor at \url{https://murcia-cs4215.github.io/frontend/}.
Alternatively, one can find the latest tagged release of OContract at \url{https://github.com/murcia-cs4215/ocontract/releases}, and follow the instructions in the README to setup OContract to run locally.

Note that the example programs in this section is displayed as if the program was executed one statement at a time using the interactive Read-Eval-Print-Loop(REPL) shell.
For more information regarding how to set up and run OContract programs, please refer to the README of the OContract repo.

\subsection{Primitive Types}

OContract supports the following primitive types: \texttt{int}, \texttt{float}, \texttt{string}, \texttt{char} and \texttt{bool}.

A basic expression is simply a primitive value. We can turn such expressions into statements by appending two semicolons:

\begin{verbatim}
    > 10;;
    - : int = 10
    > 10.5;;
    - : float = 10.5
    > "abc";;
    - : string = "abc"
    > '1';;
    - : char = '1'
    > true;;
    - : bool = true
\end{verbatim}

\subsection{Basic Operators}

OContract supports various basic operators:

\begin{itemize}
    \item Unary \texttt{not}
    \item Arithmetic operators on \texttt{int}: \texttt{+}, \texttt{-}, \texttt{/}, \texttt{*}, \texttt{mod}
    \item Arithmetic operators on \texttt{float}: \texttt{+.}, \texttt{-.}, \texttt{/.}, \texttt{*.}, \texttt{**} (power)
    \item Logical operators: \texttt{\&\&}, \texttt{||}
    \item Binary comparison operators: \texttt{<}, \texttt{>}, \texttt{<=}, \texttt{>=}, \texttt{==}, \texttt{!=}, \texttt{=}, \texttt{<>}
    \item String concatenation operator: \texttt{\^}
  \end{itemize}

This is an example of a valid OContract program that uses basic operators:

\begin{verbatim}
    > (1 + 2) - 3 * 4;;
    - : int = -9
    > (1 == 1) && (true || false);;
    - : bool = true
\end{verbatim}

Note that \texttt{=} and \texttt{<>} check for structural equality, whereas \texttt{==} and \texttt{!=} check for physical equality.
The latter describes the equality of the address of an object.
This is best exemplified via the following example program:

\begin{verbatim}
    > let x : string = "hello";;
    val x : string = "hello"
    > x = "hello";;
    - : bool = true
    > x == "hello";;
    - : bool = false
    > x == x;;
    - : bool = true
\end{verbatim}

\subsection{If Statements}

OContract supports if statements in the form of \texttt{if} ... \texttt{then} ... \texttt{else} ... .

An OContract program that uses if statements can be written like so:

\begin{verbatim}
    > if (1 > 2) then "seems wrong..." else "seems correct...";;
    - : string = "seems correct..."
\end{verbatim}

\subsection{Lambda Expressions}

Similar to OCaml, OContract allows users to define lambda expressions using the \texttt{fun} keyword.
Note that \textbf{all of the input types and output type have to be clearly specified} for the program to be valid.

To apply a lambda expression to some arguments, simply ensure that the arguments are whitespace-separated and comes after the lambda expression.

Here is an example of an OContract program using lambda expressions:

\begin{verbatim}
    > (fun (x : int) : int -> x + 1) 1;;
    - : int = 2
    > (fun (x : int) (y : int) : bool -> x > y) 1 2;;
    - : bool = false
\end{verbatim}

\subsection{Let Bindings}

Similar to OCaml, OContract allows users to define bindings of the result of an expression to an identifier using the \texttt{let} keyword.
Note that \textbf{the type of the identifier must be clearly defined}.

The binding can be defined to be valid locally via the use of the \texttt{let ... in ...} syntax.

Here is an example of some simple let bindings:

\begin{verbatim}
    > let y : int = 10;;
    val y : int = 10
    > let x : int = 10 in x + 5;;
    - : int = 15
    > y;;
    - : int = 10
    > x;;
    Uncaught Error: Line 1, Column 0: Unbound value x
\end{verbatim}

In addition to binding values to identifiers, lambda expressions are also allowed to be bound to identifiers.
This offers a convenient way of reusing the lambda expression by referring to the identifier that is bound to that lambda expression.

Let bindings also allows the user to define a function by defining symbols for the function arguments immediately after the identifier for the function.

For example, the functions \texttt{f} and \texttt{g} as shown in the two separate programs below are semantically equivalent:

\begin{verbatim}
    > let f : int -> int = fun (x : int) : int -> x + 1;;
    val f : int -> int = <fun>
    > f 1;;
    - : int = 2
    > f 2;;
    - : int = 3
\end{verbatim}

\begin{verbatim}
    > let g (x : int) : int = x + 1;;
    val g : int -> int = <fun>
    > g 1;;
    - : int = 2
    > g 2;;
    - : int = 3
\end{verbatim}

\subsection{Recursive Functions}

OContract supports defining recursive function via the \texttt{let rec f ... = ... f ... } syntax.

For example, the recursive factorial function can be defined as such:

\begin{verbatim}
    > let rec fact (x : int) : int = if x == 0 then 1 else x * (fact (x - 1));;
    val fact : int -> int = <fun>
    > fact 5;;
    - : int = 120
\end{verbatim}

Note that without the \texttt{rec}, the function name will not be bound.

\begin{verbatim}
    > let fact (x : int) : int = if x == 0 then 1 else x * (fact (x - 1));;
    Uncaught Error: Line 1, Column 54: Unbound value fact
\end{verbatim}

\subsection{Function Currying}

OContract supports the partial application of a function.

For example:

\begin{verbatim}
    > let f (x : int) (y : int) : int = x + y;;
    val f : int -> int -> int = <fun>
    > let g : int -> int = f 1;;
    val g : int -> int = <fun>
    > g 100;;
    - : int = 101
\end{verbatim}

\subsection{Higher-Order Functions}

As a functional programming language, OContract allows the user to easily define and apply higher-order functions.

For example, the program below defines a higher-order function \texttt{f} that takes in a function \texttt{g} and an integer \texttt{x}.

\begin{verbatim}
    > let f (g : int -> int) : int -> int = fun (x : int) : int -> g x;;
    val f : (int -> int) -> int -> int = <fun>
    > f (fun (x : int) : int -> x + 100) 10;;
    - : int = 110
\end{verbatim}

\subsection{Contracts and Blame Assignment}

The main feature of OContract is the ability for users to define assertion-based contracts and be notified of contract violations (if any) and the corresponding party to be blamed during runtime.

Not only does this aid in debugging, but it also gives user the reassurance that pre-conditions and post-conditions will be adhered to, regardless of how functions are passed around in the program.

\subsubsection{Predicate Contracts}

A predicate contract is a contract that is defined on an identifier that holds a primitive value.

Suppose that you wish to define a predicate contract on the identifier \texttt{x}, it can be done using the

\begin{verbatim}
contract x = E1;;
\end{verbatim}

syntax, where \texttt{E1} denotes an expression that evaluates to a function that takes in the value of \texttt{x} as input and returns a \texttt{bool}.
During runtime, if the returned value is \texttt{false}, it would indicate a contract violation and the runtime system will notify the user of that.

For example, the program below shows an example usage of predicate contracts.
The contract on \texttt{x} only allows \texttt{x} to hold integers that are greater than 0.
If \texttt{x} holds a value that is not greater than 0, a contract violation error will be thrown together with the party to be blamed (also termed the ``blame party").

\begin{verbatim}
    > contract x = (fun (y : int) : bool -> y > 0);;
    val x : int = <contract>
    > let x : int = 1;;
    val x : int = 1
    > let x : int = 0;;
    Uncaught Error: Line 1, Column 0: Contract violation!
    Blame: main
    Contract at: Line 1, Column 0
\end{verbatim}

Note that in a REPL context, each line would have a line number of 1, hence the above identical locations for both the violation and the violated contract.

\subsubsection{Function Contracts}

A function contract is a contract that is defined on an identifier that refers to a function.

To define a function contract on function \texttt{f} that takes in $k$ arguments, it can be done using the following syntax:

\begin{verbatim}
contract f = E1 -> E2 -> ... -> Ek -> Er ;;
\end{verbatim}

Each of the \texttt{Ei} ($1 \leq i \leq k$) is an expression that evaluates to a function which expects the $i$-th argument of \texttt{f} and returns a \texttt{bool}.
Finally, the last term in the contract \texttt{Er} is an expression that evaluates to a function which expects the return value of fully evaluating the function \texttt{f} and returns a \texttt{bool}.

Note that if the function takes in $k$ arguments, the contract that is defined on $f$ must have exactly $k + 1$ expressions that are separated by ``$\rightarrow$".

The following is an example of a function contract on a first-order function that takes in two integers and return their sum.
For brevity, we excluded the definition of a helper function \texttt{gt0} that takes in an integer and returns a \texttt{bool} based on whether it is greater than 0 or not.

\begin{verbatim}
    > contract f = gt0 -> gt0 -> gt0;;
    val f : int -> int -> int = <contract>
    > let f (x : int) (y : int) : int = x + y;;
    val f : int -> int -> int = <fun>
    > f 1 1;;
    - : int = 2
    > f 0 1;;
    Uncaught Error: Line 1, Column 0: Contract violation!
    Blame: main
    Contract at: Line 1, Column 0
\end{verbatim}

\subsubsection{Contracts for Higher-Order Functions}

Function contracts can also be used to define contracts for higher-order functions.

For example, the following program defines a contract for a higher-order function \texttt{compose} that takes in two functions as input and returns a function that is a composition of the two functions.
Again, we assume for brevity that there exists a helper function \texttt{gt0} that checks whether an integer is greater than 0.

\begin{verbatim}
    > contract compose = (gt0 -> gt0) -> (gt0 -> gt0) -> (gt0 -> gt0);;
    val compose : (int -> int) -> (int -> int) -> int -> int = <contract>
    > let compose (f : int -> int) (g : int -> int) : int -> int
                  = fun (x : int) : int -> f (g x);;
    val compose : (int -> int) -> (int -> int) -> int -> int = <fun>
    > compose (fun (x : int) : int -> x + 1) (fun (y: int) : int -> y + 1) 0;;
    Uncaught Error: Line 1, Column 61: Contract violation!
    Blame: main
    Contract at: Line 1, Column 0
\end{verbatim}

OContract blames \texttt{main} in this case because a faulty value of 0 was supplied to \texttt{g} as \texttt{g} was expecting an input that is greater than 0.

\subsubsection{Contract Set-Notation Syntax}

For greater user flexibility, OContract allows a user to define a contract using an alternative Set-Notation syntax.

For instance, predicate contracts can be defined as follows:

\begin{verbatim}
    > contract x = {a : int | a > 0};;
    val x : int = <contract>
\end{verbatim}

This means that \texttt{x} should hold an integer that is greater than 0.

More generally, each term on the right-hand-side of the contract declaration statement (i.e. after the ``=" sign) contains two components separated by a ``$\vert$" symbol.
The first component is a symbol that is used to identify the argument, and the second component is an expression (which could possibly involve the use of the symbol defined in the first component) that returns a \texttt{bool}.

Note that it is also possible to use set notation syntax as well as the plain expressions interchangeably in the declaration of a contract.
See the following example below:

\begin{verbatim}
    > contract f = gt0 -> {y : int | y > 100};;
    val f : int -> int = <contract>
    > let f (x : int) : int = x + 100;;
    val f : int -> int = <fun>
    > f 0;;
    Uncaught Error: Line 1, Column 0: Contract violation!
    Blame: main
    Contract at: Line 1, Column 0
\end{verbatim}

\subsubsection{Dependent Contracts}

OContract allows the user to define dependent contracts, which refers having a predicate on parameters or the return value based on the values of the previous arguments.

Note that dependent contracts can only be defined using the set-notation contract syntax.

For instance, consider the following program that defines an adder function.

\begin{verbatim}
    > contract adder = {x : int | x > 0} -> {y : int | y > 0} -> {z : int | z = x + y};;
    val adder : int -> int -> int = <contract>
    > let adder (x : int) (y : int) : int = x + 1;;
    val adder : int -> int -> int = <fun>
    > adder 1 2;;
    Uncaught Error: Line 1, Column 0: Contract violation!
    Blame: adder
    Contract at: Line 1, Column 0
\end{verbatim}

The contract of \texttt{adder} is violated due to the incorrect implementation of \texttt{adder}.
Note that this contract violation error cannot be caught if one simply uses \texttt{gt0} as the last term in the contract of \texttt{adder}.

Hence, in a sense, dependent contracts allow users to define ``stricter" contracts that provide stronger assertion guarantees.

\subsection{Static Type Checker}

OContract enforces types to be declared for all identifiers, arguments and return values.

The strong type safety of OContract results in the early detection of type errors and leads to faster development time.
A more rigorous exploration on OContract's type safety will be done in the following Section \ref{developer}.

For example, the following program shows how OContract is able to detect static type errors.

\begin{verbatim}
    > let x : int = "not an integer";;
    Uncaught:
    Error: Line 1, Column 0: This expression has type string but an expression
    was expected of type int
    > let f (x : float) : int = x + 5;;
    Uncaught:
    Error: Line 1, Column 26: This expression has type float but an expression
    was expected of type int
\end{verbatim}

In addition, OContract also has type-checking on contracts and is able to detect type mismatch errors.

For example, the following program shows how OContract is able to detect type mismatch errors with respect to contracts.

\begin{verbatim}
    > contract f = {x : int | x > 0};;
    val f : int = <contract>
    > let f : string = "not an int";;
    Uncaught:
    Error: Line 1, Column 0: This name has type string but its contract
    was expecting type int
    > contract g = {x : int | "not a bool"};;
    Uncaught:
    Error: Line 1, Column 13: This expression has type string but an expression
    was expected of type bool
\end{verbatim}

Although there is also runtime type checking occurring in OContract, it serves more as a safety net from a programming point of view.
The runtime type checking would never find errors should the program pass the static type checker.

\subsection{In-Built Functions and Predicates}

To enhance the user experience, OContract comes packaged with a subset of OCaml's library functions and constants.
These primarily come from OCaml's \texttt{Float} and \texttt{String} libraries.

\begin{center}
\begin{tabular}{|l|l|l|l|l|}
    \hline
    \multicolumn{3}{|c|}{\texttt{Float}} & \texttt{String} & Others \\ \hline
    \texttt{infinity} & \texttt{neg\_infinity} & \texttt{nan} & \texttt{empty} & \texttt{positive} \\
    \texttt{pi} & \texttt{is\_nan} & \texttt{of\_int} & \texttt{make} & \texttt{negative} \\
    \texttt{to\_int} & \texttt{sqrt} & \texttt{cbrt} & \texttt{length} & \texttt{zero} \\
    \texttt{exp} & \texttt{exp2} & \texttt{log} & \texttt{get} & \texttt{any} \\
    \texttt{log10} & \texttt{log2} & \texttt{expm1} & \texttt{starts\_with} & \texttt{to\_string} \\
    \texttt{log1p} & \texttt{cos} & \texttt{sin} & \texttt{ends\_with} & \\
    \texttt{tan} & \texttt{acos} & \texttt{asin} & \texttt{contains} & \\
    \texttt{atan} & \texttt{atan2} & \texttt{hypot} & \texttt{substring} & \\
    \texttt{cosh} & \texttt{sinh} & \texttt{tanh} & \texttt{uppercase} & \\
    \texttt{acosh} & \texttt{asinh} & \texttt{atanh} & \texttt{lowercase} & \\
    \texttt{round} & \texttt{ceil} & \texttt{floor} & \texttt{capitalize} & \\ \hline
\end{tabular}
\end{center}

There are four predicates introduced to make writing contracts easier --- \texttt{positive}, \texttt{negative}, \texttt{zero}, and \texttt{any}.
The first three predicates do as their names suggest.
\texttt{positive} checks that a value is positive, \texttt{negative} checks that a value is negative, and \texttt{zero} checks that a value is zero.

What is interesting about them, however, is that they work with a new type called \texttt{numeric}.

\begin{verbatim}
    > positive;;
    - : numeric -> bool = <fun>
    > positive 10;;
    - : bool = true
    > positive (-0.5);;
    - : bool = false
\end{verbatim}

In other words, these three functions are able to take in both \texttt{int} and \texttt{float} values.
But do note that this new type \texttt{numeric} is only for internal usage, and cannot be used explicitly for type declarations.

Similarly, \texttt{any} uses a new internal type called \texttt{any}, that accepts all types.
\texttt{any} thus takes in any value and returns \texttt{true}, serving as an effective ``empty'' predicate for contracts.
The example below uses this property to avoid any checks on the return value of \texttt{f}.

\begin{verbatim}
    > any;;
    - : any -> bool = <fun>
    > contract f = positive -> any;;
    val f : numeric -> any = <contract>
    > let f (x : int) : string = to_string x;;
    val f : int -> string = <fun>
    > f 20;;
    - : string = "20"
\end{verbatim}

Do note that, though convenient, excessive usage of \texttt{any} defeats the purpose of assertions as a whole.

\section{OContract Formal Specification}
\label{developer}

In this section, we define the formal semantics of OContract and describe the implementation of our interpreter of OContract in detail.

For steps on running an OContract program, please refer to Section \ref{user}.

We first begin by defining the syntax of OContract.
We then bring in the type system and define it using static semantics.
This is then synergised with how our interpreter behaves, described using the framework of denotational semantics.

\subsection{Syntax of OContract}

We divide the syntax of OContract into three categories, \textit{expressions}, \textit{contracts} and \textit{statements}.

\subsubsection*{Expressions}

The set of expressions $E$ is the least set that satisfies the following rules, where $x$ ranges over a set of names $V$,
$n$ ranges over the set of expressible integers, $f$ ranges over the set of expressible floats, $c$ ranges over the
set of all characters and $s$ ranges over the set of expressible strings.

We also define $p_1$ ranging over the set of unary primitive operations $P_1=\{\verb|not|\}$
and $p_2$ ranging over the set of binary primitive operations $P_2=\{\verb@||@,\verb#&&#, \verb#+#, \verb#-#,\verb#*#,\verb#/#, \verb#mod#,
\verb#+.#, \verb#-.#,\verb#*.#,\verb#/.#, \verb#**#,\verb#<#, \verb#>#, \verb#<=#, \verb#>=#, \verb#==#, \verb#!=#, \verb#=#, \verb#<>#, \verb#^#\}$.

Lastly, we define $t$ to represent an arbitrary type.
We will further formalise the set of types later.

$\Rule{}{x}$
\hfill
$\Rule{}{n}$
\hfill
$\Rule{}{f}$
\hfill
$\Rule{}{c}$
\hfill
$\Rule{}{s}$
\hfill
$\Rule{}{\TruE}$
\hfill
$\Rule{}{\FalsE}$

$\RuleWithName{E}{p_1[E]}{UnaryOp}$
\hfill
$\RuleWithName{E_1\quad E_2}{p_2[E_1, E_2]}{BinaryOp}$
\hfill
$\RuleWithName{E\qquad E_1\qquad E_2}{\texttt{if}\ E\ \texttt{then}\ E_1\ \texttt{else}\ E_2}{CondExp}$
\hfill
$\RuleWithName{E\quad E_1}{E\ E_1}{FuncApp}$

$\RuleWithName{E_1\quad E_2}{\texttt{let}\ x\ :\ t\ \texttt{=}\ E_1\ \texttt{in}\ E_2}{LocalLet}$
\hfill
$\RuleWithName{E_1\quad E_2}{\texttt{let}\ x\ (x_1\ :\ t_1)\ \cdots\ (x_n\ :\ t_n)\ :\ t\ \texttt{=}\ E_1\ \texttt{in}\ E_2}{LocalLetFunc}$

$\RuleWithName{E}{\texttt{fun}\ (x_1\ :\ t_1)\ \cdots\ (x_n\ :\ t_n)\ :\ t\ \texttt{=}\ E}{LambdaExp}$

It may seem counter-intuitive that a local let ``statement'' is actually an expression.
We can see why this is the case using the following example:

\begin{verbatim}
    > 40 = (let n : int = 2 in n + n) * 10;;
    - : bool = true
\end{verbatim}

\subsubsection*{Contracts}

The set of contracts $C$ is the least set that satisfies the following rules:

$\Rule{E}{E}$
\hfill
$\RuleWithName{E}{\{x\ :\ t\ |\ E\}}{SetNotation}$
\hfill
$\RuleWithName{C_1\quad\cdots\quad C_n}{(C_1\ \texttt{->}\ \cdots\ \texttt{->}\ C_n)}{FuncContract}$

\subsubsection*{Statements}

Finally, the set of statements $S$ is the least set that satisfies the following rules:

$\Rule{E}{E\texttt{;;}}$
\hfill
$\RuleWithName{S_1\quad S_2}{S_1\ S_2}{Sequence}$
\hfill
$\RuleWithName{C}{\texttt{contract}\ x\ \texttt{=}\ C\texttt{;;}}{ContractDecl}$
\hfill
$\RuleWithName{E}{\texttt{let}\ x\ :\ t\ \texttt{=}\ E\texttt{;;}}{GlobalLet}$
\hfill
$\RuleWithName{E}{\texttt{let}\ x\ (x_1\ :\ t_1)\ \cdots\ (x_n\ :\ t_n)\ :\ t\ \texttt{=}\ E\texttt{;;}}{GlobalLetFunc}$

For completeness, let us formally define the set of types $t$ as well.

$\Rule{}{\texttt{int}}$
\hfill
$\Rule{}{\texttt{float}}$
\hfill
$\Rule{}{\texttt{char}}$
\hfill
$\Rule{}{\texttt{string}}$
\hfill
$\Rule{}{\texttt{bool}}$
\hfill
$\RuleWithName{t_1\quad t_2}{t_1\ \texttt{->}\ t_2}{FuncType}$

\subsection{Syntactic Conventions}

We introduce the syntactic conventions to follow:

\begin{itemize}
    \item We can use parentheses in order to group expressions and types together.
    \item We use the usual infix and prefix notation for operators.
    \item The type constructor \verb|->| is right-associative, so that the type
\begin{verbatim}
    int -> int -> int
\end{verbatim}
    is equivalent to:
\begin{verbatim}
    int -> (int -> int)
\end{verbatim}
\end{itemize}

Thus, the function

\begin{verbatim}
    > let f : int -> int -> int = fun (x : int) (y : int) : int -> x + y;;
    val f : int -> int -> int = <fun>
\end{verbatim}

takes in an integer \verb|x| and returns a function (due to currying), whereas the function

\begin{verbatim}
    > let h : (int -> int) -> int = fun (f : int -> int) : int -> f 10;;
    val h : (int -> int) -> int = <fun>
\end{verbatim}

takes a function \verb|f| as an argument and returns an integer.

\subsection{Static Semantics of OContract's Type System}

Not all statements in OContract make sense. For example,

\begin{verbatim}
    contract x = 5;;
\end{verbatim}

does not make sense, because we expect some form of callable function for contract checking, while \verb|5| is just an integer.
We thus say that this statement is \textit{ill-typed}, because a typing condition is not met.
Statements that meet these conditions are what we call \textit{well-typed} in OContract.

An expression \verb|x + 5| within a statement may or may not be well-typed, depending on the type of \verb|x|.
For the following parts, we define $\Gamma$ to denote the type environment.
$\Gamma$ effectively serves as a partial function from names to types, with which a name $x$ is associated with type $\Gamma(x)$.

We further define a relation $\Gamma[x\leftarrow t]\Gamma'$, which constructs a new type environment where $\Gamma'(y)$ is $t$ if $y=x$ and $\Gamma(y)$ otherwise.
The set of names, on which a type environment $\Gamma$ is defined is called the domain of $\Gamma$, denoted by $dom(\Gamma)$.
We define the empty type environment $\Gamma=\emptyset$.

Lastly, to contract declaration, we will need to define a separate contract type environment $\Gamma_c$, which specifically stores contract types and otherwise works much like the normal environment.
This is due to the name conflict when a name has both a contract type and its actual type.

The full environment is thus a pair $(\Gamma, \Gamma_c)$.

\subsubsection{Primitive Values and Symbols}

We define the typing relation inductively with the following rules.

$\RuleWithName{}{(\Gamma, \Gamma_c) \vdash x : \Gamma \Lp x \Rp}{Var1T}$
\hfill
$\RuleWithName{}{(\Gamma, \Gamma_c) \vdash_c x : \Gamma_c \Lp x \Rp}{Var2T}$
\hfill
$\RuleWithName{}{(\Gamma, \Gamma_c) \vdash n : \Int}{IntT}$
\hfill
$\RuleWithName{}{(\Gamma, \Gamma_c) \vdash f : \Float}{FloatT}$
\hfill
$\RuleWithName{}{(\Gamma, \Gamma_c) \vdash c : \Char}{CharT}$
\hfill
$\RuleWithName{}{(\Gamma, \Gamma_c) \vdash s : \String}{StringT}$
\hfill
$\RuleWithName{}{(\Gamma, \Gamma_c) \vdash \TruE : \Bool}{TrueT}$
\hfill
$\RuleWithName{}{(\Gamma, \Gamma_c) \vdash \FalsE : \Bool}{FalseT}$

If $\Gamma(x)$ is not defined, then the first rule is not applicable.
If $\Gamma_c(x)$ is not defined, then the second rule is not applicable.
In this case, we say that there is no type for $x$ derivable from the assumptions $\Gamma$.

\subsubsection{Expressions}

The following rules describes the set of expressions in OContract,
where we define the type of \Num\ to denote \Int\ or \Float\ for convenience.

$\RuleWithName{(\Gamma, \Gamma_c) \vdash E\ :\ \Bool}{(\Gamma, \Gamma_c) \vdash \texttt{not}\ E\ :\ \Bool}{NotT}$
\hfill
$\RuleWithName{(\Gamma, \Gamma_c) \vdash E\ :\ \Num}{(\Gamma, \Gamma_c) \vdash - E\ :\ \Num}{NegativeT}$

For each binary primitive operation $p_2$, we have a rule of the following form:

\begin{center}
    $\RuleWithName{(\Gamma, \Gamma_c) \vdash E_1\ :\ t_1\ \quad E_2\ :\ t_2}{(\Gamma, \Gamma_c) \vdash p_2[E_1, E_2]\ :\ t}{BinOpT}$
\end{center}

where the types $t_1, t_2, t$ are given by the following table.

\begin{tabular}{|l||l|l|l|} \hline
    $p$ & $t_1$ & $t_2$ & $t$ \\ \hline \hline
    \verb#+,-,*,/,mod# & \Int & \Int & \Int \\ \hline
    \verb#+.,-.,*.,/.,**# & \Float & \Float & \Float \\ \hline
    \verb#&&,||#  & \Bool & \Bool & \Bool \\ \hline
    \verb#<=,<,>=,># & \Int & \Int & \Bool \\ \hline
    \verb#<=,<,>=,># & \Float & \Float & \Bool \\ \hline
    \verb#==,!=,=,<># & t' & t' & t' \\ \hline
    \verb#^# & \String & \String & \String \\ \hline
\end{tabular}
\vspace{3mm}

For conditional expressions, we also enforce that the consequent and alternative expressions have the same type:

\begin{center}
    $\RuleWithName{(\Gamma, \Gamma_c) \vdash E\ :\ \Bool \qquad (\Gamma, \Gamma_c) \vdash E_1\ :\ t\ \qquad (\Gamma, \Gamma_c) \vdash E_2\ :\ t}{(\Gamma, \Gamma_c) \vdash \texttt{if}\ E\ \texttt{then}\ E_1\ \texttt{else}\ E_2\ : t}{IfT}$
\end{center}

For local let bindings, the type of the expression is the type of the right hand side, after the type of the left hand side has been bound..

\begin{center}
    $\RuleWithName{(\Gamma, \Gamma_c) \vdash E_1\ :\ t_1\ \qquad (\Gamma, \Gamma_c) [x \leftarrow t_1](\Gamma', \Gamma_c) \vdash E_2\ :\ t_2}{(\Gamma, \Gamma_c) \vdash \texttt{let}\ x\ :\ t_1\ \texttt{=}\ E_1\ \texttt{in}\ E_2\ :\ t_2}{LocalLetT}$

    $\Rule{(\Gamma, \Gamma_c) [x_1 \leftarrow t_1] (\Gamma_1, \Gamma_c) \cdots (\Gamma_{n-1}, \Gamma_c) [x_n \leftarrow t_n] (\Gamma_n, \Gamma_c) \vdash E_1\ :\ t\ \quad (\Gamma, \Gamma_c) [f \leftarrow t_1\ \texttt{->}\ \cdots\ \texttt{->}\ t_n \texttt{->}\ t] \vdash E_2\ :\ t_r}
    {(\Gamma, \Gamma_c) \vdash \texttt{let}\ f\ (x_1\ :\ t_1)\ \cdots\ (x_n\ :\ t_n)\ :\ t\ \texttt{=}\ E_1\ \texttt{in}\ E_2\ :\ t_r}$
    [LocalLetFuncT]
\end{center}


We have a similar rule for lambda expressions:

\begin{center}
    $\Rule{(\Gamma, \Gamma_c) [x_1 \leftarrow t_1](\Gamma_1, \Gamma_c) \cdots (\Gamma_{n-1}, \Gamma_c)[x_n \leftarrow t_n](\Gamma_n, \Gamma_c) \vdash E\ :\ t}
        {(\Gamma, \Gamma_c) \vdash \texttt{fun}\ (x_1\ :\ t_1)\ \cdots\ (x_n\ :\ t_n)\ :\ t\ \rightarrow E\ :\ t_1 \rightarrow \cdots \rightarrow t_n \rightarrow t}$
\end{center}

Lastly, for function application:

\begin{center}
    $\RuleWithName{(\Gamma, \Gamma_c) \vdash E\ :\ t_1\ \rightarrow\  t_2\ \quad (\Gamma, \Gamma_c) \vdash E_1\ :\ t_1}{(\Gamma, \Gamma_c) \vdash E\ E_1\ :\ t_2}{FuncAppT}$
\end{center}

Note that as OContract supports function currying out-of-the-box, the above rule can be extended to work for expressions such as \verb|f 1 2 3|.

\subsubsection{Contracts}

There are two main types of contracts --- predicate contracts (or flat contracts), which work on primitives, and function contracts, which work on functions.

There are two possible syntaxes for predicate contracts:

$\Rule{(\Gamma, \Gamma_c) \vdash E\ :\ t\ \rightarrow\ \texttt{bool}}{(\Gamma, \Gamma_c) \vdash E\ :\ \texttt{contract}\ t}$
\hfill
$\RuleWithName{(\Gamma, \Gamma_c) [x \leftarrow t] (\Gamma', \Gamma_c) \vdash E\ :\ t\ \rightarrow\ \texttt{bool}}{(\Gamma, \Gamma_c) \vdash \{x\ :\ t\ |\ E\}\ :\ \texttt{contract}\ t}{SetNotationT}$

where \verb|contract| $t$ is defined as the type of a contract that takes in type $t$.

For function contracts, we thus have:

\begin{center}
    $\RuleWithName{(\Gamma, \Gamma_c) \vdash C_1\ :\ \texttt{contract}\ t_1\ \cdots\ (\Gamma, \Gamma_c) \vdash C_n\ :\ \texttt{contract}\ t_n}{(\Gamma, \Gamma_c) \vdash C_1\ \texttt{->}\ \cdots\ \texttt{->}\ C_n\ :\ \texttt{contract}\ t_1\ \texttt{->}\ \cdots\ \texttt{->}\ t_n}{FuncContractT}$
\end{center}

\subsubsection{Statements}

The following rules applies for statements in OContract:

$\Rule{(\Gamma, \Gamma_c) \vdash E\ :\ t}{\Gamma \vdash E;;\ :\ t}$
\hfill
$\RuleWithName{(\Gamma, \Gamma_c)[x\leftarrow t](\Gamma', \Gamma_c)\quad(\Gamma', \Gamma_c) \vdash S\ :\ t'}{(\Gamma, \Gamma_c) \vdash \texttt{let}\ (x\ :\ t)\ =\ E;;\ S\ :\ t'}{Sequence1T}$
\begin{center}
    $\RuleWithName{(\Gamma, \Gamma_c) \vdash S_1\ :\ t_1\quad (\Gamma, \Gamma_c)\vdash S_2\ :\ t_2}{(\Gamma, \Gamma_c) \vdash S_1\ S_2\ :\ t_2}{Sequence2T}$
    where $S_1$ is not a global let nor contract declaration statement.
\end{center}

Contract declarations, by themselves, more or less work like other statements:

\begin{center}
    $\RuleWithName{(\Gamma, \Gamma_c) \vdash C\ :\ \texttt{contract}\ t}{(\Gamma, \Gamma_c) \vdash \texttt{contract}\ (x\ :\ t)\ =\ C;;\ :\ \texttt{unit}}{ContractDeclT}$
\end{center}

where \verb|unit| is a special type, which is used when the statement does not possess any type.
Do note that the type here is not the same as the output you see when you do a contract declaration on the REPL, which is printed out more for usability purposes.

Contract declarations do have the following effect on sequences, however:

\begin{center}
    $\RuleWithName{(\Gamma, \Gamma_c)\vdash C\ :\ \texttt{contract}\ t\quad (\Gamma, \Gamma_c)[x\leftarrow \texttt{contract}\ t](\Gamma, \Gamma_c')\quad(\Gamma, \Gamma_c') \vdash S\ :\ t'}{(\Gamma, \Gamma_c)\vdash \texttt{contract}\ x\ =\ C;;\ S\ :\ t'}{Sequence3T}$
\end{center}

This mainly affects bindings, since type checking is performed when a binding is done to a name that already has a contract.

\begin{center}
    $\RuleWithName{(\Gamma, \Gamma_c) \vdash E\ :\ t}{(\Gamma, \Gamma_c) \vdash \texttt{let } (x\ :\ t)\ \texttt{ = } E;;\ :\ \texttt{unit}}{GlobalLet1T}$
    if $x \notin dom(\Gamma_c)$

    $\RuleWithName{(\Gamma, \Gamma_c) \vdash E\ :\ t\quad (\Gamma, \Gamma_c)\vdash_c x\ :\ \texttt{contract}\ t}{(\Gamma, \Gamma_c) \vdash \texttt{let } (x\ :\ t)\ \texttt{ = } E;;\ :\ \texttt{unit}}{GlobalLet2T}$
    if $x \in dom(\Gamma_c)$
\end{center}


Similarly for functions:

\begin{center}
    $\RuleWithName{(\Gamma, \Gamma_c) [x_1 \leftarrow t_1] (\Gamma_1, \Gamma_c) \cdots (\Gamma_{n-1}, \Gamma_c) [x_n \leftarrow t_n] (\Gamma_n, \Gamma_c) \vdash E\ :\ t}
        {(\Gamma, \Gamma_c) \vdash \texttt{let}\ f\ (x_1\ :\ t_1)\ \cdots\ (x_n\ :\ t_n)\ :\ t\ \texttt{=}\ E;;\ :\ \texttt{unit}}{GlobalLetFunc1T}$
        if $f \notin dom(\Gamma_c)$

    $\Rule{(\Gamma, \Gamma_c) [x_1 \leftarrow t_1] (\Gamma_1, \Gamma_c) \cdots (\Gamma_{n-1}, \Gamma_c) [x_n \leftarrow t_n] (\Gamma_n, \Gamma_c) \vdash E\ :\ t\quad (\Gamma,\Gamma_c) \vdash_c f\ :\ \texttt{contract}\ t_1\ \texttt{->}\ \cdots\ \texttt{->}\ t_n \texttt{->}\ t}
        {(\Gamma, \Gamma_c) \vdash \texttt{let}\ f\ (x_1\ :\ t_1)\ \cdots\ (x_n\ :\ t_n)\ :\ t\ \texttt{=}\ E;;\ :\ \texttt{unit}}$
        [GlobalLetFunc1T] if $f \in dom(\Gamma_c)$
\end{center}

\subsection{Semantic Rules}

This section covers the denotational semantic rules that specifies the correctness of an OContract program.
Note that this section will not cover rules regarding the contract semantics as that will be covered in the next section.

For brevity, types are omitted from certain rules if they are not essential for understanding those rules.
In addition, we only consider well-typed OContract programs as per the typing rules in the previous section.

The semantic domains are as follows:

\vspace{3mm}
\begin{center}
\begin{tabular}{|l|ll|} \hline
Semantic domain & Definition & Explanation\\ \hline
\textbf{Bool} & $\{\textit{true}, \textit{false}\}$ & ring of booleans  \\
\textbf{Int}  & $\mathbb{Z}$     & set of all integers \\
\textbf{Float}  & $\mathbb{R} \setminus \mathbb{Z}$     & set of all real numbers excluding integers \\
\textbf{Num}  & $\mathbb{R}$     & set of all real numbers \\
\textbf{Char}  & character     & character \\
\textbf{String}  & string     & string \\
\textbf{EV}   & $\textbf{Bool} \boldsymbol{+} \textbf{Num} \boldsymbol{+} \textbf{Char} \boldsymbol{+} \textbf{String} \boldsymbol{+} \textbf{Fun} $     & expressible values \\
\textbf{DV}   & $\textbf{Bool} \boldsymbol{+} \textbf{Num} \boldsymbol{+} \textbf{Char} \boldsymbol{+} \textbf{String} \boldsymbol{+} \textbf{Fun} $     & denotable values \\
\textbf{Id}   & alphanumeric string     & identifiers \\
\textbf{Env}   & $\textbf{Id} \partfun \textbf{DV}$ & environments \\
\textbf{Fun}   & $\textbf{DV} \boldsymbol{*} \cdots \boldsymbol{*} \textbf{DV} \partfun \textbf{EV}$ & function values \\ \hline
\end{tabular}
\end{center}

The semantic rules are as follows:

$\Rule{\Delta \under E \eval \TruE}{\Delta \under \texttt{not}\ E \eval \FalsE}$
\hfill
$\Rule{\Delta \under E \eval \FalsE}{\Delta \under \texttt{not}\ E \eval \TruE}$
\hfill
$\Rule{\Delta \under E \eval v\ :\ \Num}{\Delta \under -E \eval -v\ :\ \Num}$
\hfill
$\Rule{\Delta \under E_1 \eval v_1 \qquad \Delta \under E_2 \eval v_2}{\Delta \under p_2[E_1, E_2]\ \eval v}$ [BinOp]

$\Rule{\Delta \under E \eval \TruE \qquad \Delta \under E_1 \eval v}{\Delta \under \texttt{if}\ E\ \texttt{then}\ E_1\ \texttt{else}\ E_2\ \eval v}$
\hfill
$\Rule{\Delta \under E \eval \FalsE \qquad \Delta \under E_2 \eval v}{\Delta \under \texttt{if}\ E\ \texttt{then}\ E_1\ \texttt{else}\ E_2\ \eval v}$

$\Rule{\Delta \under E_1 \eval v_1 \qquad \Delta[x \leftarrow v_1] \under E_2 \eval v_2}{\Delta \under \texttt{let}\ x\ \texttt{=}\ E_1\ \texttt{in}\ E_2\ \eval v_2}$

$\Rule{\Delta \under E \eval (f, \Delta') \quad \Delta \under E_1 \eval v_1}
{\Delta \under E\ E_1\ \eval \Delta' \under f\ v_1}$ [Function Application]

For the Function Application rule above, $(f, \Delta')$ is a closure representing the lambda function $f$ and environment $\Delta'$.

$\Rule{}{\Delta \under \texttt{fun}\ x_1 \cdots x_n \rightarrow E \eval (f, \Delta)}$

For the lambda function definition rule above, $f$ is defined to be such that $f\ v_1 \cdots v_n$ yields a result that is
equivalent to evaluating $\Delta[x_1 \leftarrow v_1] \cdots [x_n \leftarrow v_n] \under E$.

$\Rule{\Delta \under E \eval v \qquad \Delta[x \leftarrow v] \under S \eval v'}
{\Delta \under \texttt{let}\ x \texttt{ = } E\ ;;\ S \eval v'}$ [Let Global Binding]

For the BinOp rule, the value $v$ is given by the following table.
The symbol ``op'' in the table refers to any of the binary operation in the same row.

Most of the operations should be self-explanatory, such as $v_1\ \texttt{op}_{\Int}\ v_2$, when $\texttt{op}_{\Int}$ is ``+'', then $v = v_1 + v_2$.

\begin{tabular}{|l||l|l|l|} \hline
$p$ & $v$ \\ \hline \hline
\verb#+,-,*,/,mod# & $v_1\ \texttt{op}_{\Int}\ v_2$ \\ \hline
\verb#+.,-.,*.,/.,**# & $v_1\ \texttt{op}_{\Float}\ v_2$ \\ \hline
\verb#&&,||#  & $v_1\ \texttt{op}_{\Bool}\ v_2$ \\ \hline
\verb#<=,<,>=,># & $v_1\ \texttt{op}_{\Int \_ \texttt{comparison}}\ v_2$ \\ \hline
\verb#<=,<,>=,># & $v_1\ \texttt{op}_{\Float \_ \texttt{comparison}}\ v_2$  \\ \hline
\verb#==,!=,=,<># & $v_1\ \texttt{op}_{\texttt{equality\_check}}\ v_2$ \\ \hline
\verb#^# & $v_1\ \texttt{op}_{\texttt{string\_concatenation}}\ v_2$ \\ \hline
\end{tabular}
\vspace{3mm}

\subsection{Contract Semantics}

There are two types of contracts:
\begin{enumerate}
    \item Flat / Predicate contracts, which are predicates that can be applied to a primitive value and return boolean values.
    \item Function contracts, which apply to functions and have contracts for each of their parameters and the return value.
\end{enumerate}

Each contract comes attached with a \textbf{positive} and \textbf{negative} party.
When a contract is violated, we want to blame the \textbf{positive} party.

We only need to set the positive and negative parties for identifiers in the code, since that is where contract checks and violations are needed.

Intuitively, we can think of it as such:
\begin{enumerate}
    \item Positive party as the \textbf{Supplier}, which starts off as the identifier itself
    \item Negative party as the \textbf{Consumer}, which starts off as the “scope” of the identifier, i.e. nearest global let, else “main”.
\end{enumerate}

The initial assignment of the positive and negative blame parties is done statically before the program is run by
doing a Depth-First-Search of the AST and keeping track of the current scope at current node.

To capture the additional information of the contract as well as the positive and negative blame parties,
we update the environment in which an expression $E$ is evaluated as a tuple consisting of the contract,
the positive blame party, the negative blame party, and the environment which stores a mapping of identifiers to values.

The following are the semantic rules for flat contracts. If the predicate on the contract evaluates to \FalsE, then
the postiive blame party is blamed. Otherwise, we simply return the valid $v$.

$\Rule{\Delta \under E \eval v \quad \Delta \under \flatCon v \eval \FalsE}
{(\flatCon, p, n, \Delta) \under E \eval \blame p}$

$\Rule{\Delta \under E \eval v \quad \Delta \under \flatCon(v) \eval \TruE}
{(\flatCon, p, n, \Delta) \under E \eval v}$

The following are the semantic rules for function contracts. The key thing to note is then during
function application, the context that is propagated to the argument consists of the argument-portion of the contract,
and the positive and negative blame parties are swapped. This is because the consumer of the result of evaluating the argument
is now the supplier of the function application expression, and the supplier of the result of evaluating the argument
is now the consumer of the function application expression.

$\Rule{\Delta \under E_1 \eval (f, \Delta') \quad (\conA, n, p, \Delta) \under E_2 \eval e_2}
{(\funCon, p, n, \Delta) \under E_1 E_2 \eval e_2}$ if $e_2$ \texttt{is a blame}

$\Rule{\Delta \under E_1 \eval (f, \Delta') \quad (\conA, n, p, \Delta) \under E_2 \eval e_2 \quad (\conB, p, n, \Delta') \under f\ e_2 \eval v }
{(\funCon, p, n, \Delta) \under E_1\ E_2 \eval v}$ if $e_2$ \texttt{is not a blame}

\subsection{Implementation Details}

\subsection{Future Work}

\subsubsection{Type Inference}

\bibliographystyle{unsrt}
\bibliography{ref}

\end{document}